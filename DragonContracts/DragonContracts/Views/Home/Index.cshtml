@{
    ViewBag.Title = "Home";
}
@section Scripts {
    @Scripts.Render("~/bundles/knockout")

    <script type="text/javascript">
        function ContractsViewModel() {
            var self = this;
            self.loaded = ko.observable(false);
            self.contracts = ko.observableArray([]);
            self.emptyContractJs = null;
            self.newContract = ko.observable();
            self.searchText = ko.observable();
            self.suggestions = ko.observableArray([]);

            self.createContractFromForm = function(formElement) {
                // If valid, post the serialized form data to the web api

                $.validator.unobtrusive.parse($(formElement));

                var val = $(formElement).validate();
                var isValid = val.form();
                if (isValid) {
                    var newContractJs = ko.mapping.toJS(self.newContract);

                    //var json = ko.mapping.toJSON(self.newContract);
                    //alert(json);

                    $.post("/api/contract", newContractJs, "json")
                        .done(function(status) {
                            //alert(status);
                            self.contracts.push(newContractJs);
                        });

                    self.newContract(ko.mapping.fromJS(self.emptyContractJs));

                    self.newContract().SignedOn(moment().format());

                    $("[datepicker='datepicker']").datepicker();
                }
            };

            self.searchContracts = function() {
                self.loaded(false);
                self.contracts.removeAll();

                $.getJSON("/api/contracts?filter=" + self.searchText(), self.contracts)
                    .done(function () {
                        self.loaded(true);
                    });
            };

            self.removeContact = function(contact) {
                // First remove from the server, then from the UI
                $.ajax({ type: "DELETE", url: contact.Self })
                    .done(function() { self.contracts.remove(contact); });
            };

            // Load the initial state
            $.getJSON("/api/contract")
                .done(function(data) {
                    self.emptyContractJs = data;
                    self.newContract(ko.mapping.fromJS(data));

                    $("[datepicker='datepicker']").datepicker();
                });

            $.getJSON("/api/contracts", self.contracts)
                .done(function() {
                    self.loaded(true);

                    //test to rewrite ids for use with Html.Partial
                    //$("#firstParty").find("[id]").each(function (index, element) {
                    //    element.parent()
                    //});
                });
        }

        $(function() {
            $.datepicker.setDefaults($.datepicker.regional['cs']);
        });

        function getSuggestions(searchTerm, sourceArray) {
            $.ajax({
                url: "/api/contracts",
                data: { suggest: searchTerm },
                dataType: 'json',
                type: 'GET',
                success: function (data) {
                    sourceArray(data.Suggestions);
                }
            });
        };
        
        jQuery.validator.methods["date"] = function(value, element) {
            try {
                jQuery.datepicker.parseDate('d.m.yy', value);
                return true;
            } catch(e) {
                return false;
            }
        };

        moment.lang("cs");

        //jqAuto -- main binding (should contain additional options to pass to autocomplete)
        //jqAutoSource -- the array to populate with choices (needs to be an observableArray)
        //jqAutoQuery -- function to return choices
        //jqAutoValue -- where to write the selected value
        //jqAutoSourceLabel -- the property that should be displayed in the possible choices
        //jqAutoSourceInputValue -- the property that should be displayed in the input box
        //jqAutoSourceValue -- the property to use for the value
        ko.bindingHandlers.jqAuto = {
            init: function (element, valueAccessor, allBindingsAccessor, viewModel) {
                var options = valueAccessor() || {},
                    allBindings = allBindingsAccessor(),
                    unwrap = ko.utils.unwrapObservable,
                    modelValue = allBindings.jqAutoValue,
                    source = allBindings.jqAutoSource,
                    query = allBindings.jqAutoQuery,
                    valueProp = allBindings.jqAutoSourceValue,
                    inputValueProp = allBindings.jqAutoSourceInputValue || valueProp,
                    labelProp = allBindings.jqAutoSourceLabel || inputValueProp;

                //function that is shared by both select and change event handlers
                function writeValueToModel(valueToWrite) {
                    if (ko.isWriteableObservable(modelValue)) {
                        modelValue(valueToWrite);
                    } else {  //write to non-observable
                        if (allBindings['_ko_property_writers'] && allBindings['_ko_property_writers']['jqAutoValue'])
                            allBindings['_ko_property_writers']['jqAutoValue'](valueToWrite);
                    }
                }

                //on a selection write the proper value to the model
                options.select = function (event, ui) {
                    writeValueToModel(ui.item ? ui.item.actualValue : null);
                };

                //on a change, make sure that it is a valid value or clear out the model value
                options.change = function (event, ui) {
                    var currentValue = $(element).val();
                    var matchingItem = ko.utils.arrayFirst(unwrap(source), function (item) {
                        return unwrap(inputValueProp ? item[inputValueProp] : item) === currentValue;
                    });

                    if (!matchingItem) {
                        writeValueToModel(null);
                    }
                }

                //hold the autocomplete current response
                var currentResponse = null;

                //handle the choices being updated in a DO, to decouple value updates from source (options) updates
                var mappedSource = ko.dependentObservable({
                    read: function () {
                        mapped = ko.utils.arrayMap(unwrap(source), function (item) {
                            var result = {};
                            result.label = labelProp ? unwrap(item[labelProp]) : unwrap(item).toString();  //show in pop-up choices
                            result.value = inputValueProp ? unwrap(item[inputValueProp]) : unwrap(item).toString();  //show in input box
                            result.actualValue = valueProp ? unwrap(item[valueProp]) : item;  //store in model
                            return result;
                        });
                        return mapped;
                    },
                    write: function (newValue) {
                        source(newValue);  //update the source observableArray, so our mapped value (above) is correct
                        if (currentResponse) {
                            currentResponse(mappedSource());
                        }
                    },
                    disposeWhenNodeIsRemoved: element
                });

                if (query) {
                    options.source = function (request, response) {
                        currentResponse = response;
                        query.call(this, request.term, mappedSource);
                    }
                } else {
                    //whenever the items that make up the source are updated, make sure that autocomplete knows it
                    mappedSource.subscribe(function (newValue) {
                        $(element).autocomplete("option", "source", newValue);
                    });

                    options.source = mappedSource();
                }


                //initialize autocomplete
                $(element).autocomplete(options);
            },
            update: function (element, valueAccessor, allBindingsAccessor, viewModel) {
                //update value based on a model change
                var allBindings = allBindingsAccessor(),
                    unwrap = ko.utils.unwrapObservable,
                    modelValue = unwrap(allBindings.jqAutoValue) || '',
                    valueProp = allBindings.jqAutoSourceValue,
                    inputValueProp = allBindings.jqAutoSourceInputValue || valueProp;

                //if we are writing a different property to the input than we are writing to the model, then locate the object
                if (valueProp && inputValueProp !== valueProp) {
                    var source = unwrap(allBindings.jqAutoSource) || [];
                    var modelValue = ko.utils.arrayFirst(source, function (item) {
                        return unwrap(item[valueProp]) === modelValue;
                    }) || {};
                }

                //update the element with the value that should be shown in the input
                $(element).val(modelValue && inputValueProp !== valueProp ? unwrap(modelValue[inputValueProp]) : modelValue.toString());
            }
        };

        ko.bindingHandlers.date = {
            init: function(element, valueAccessor, allBindingsAccessor) {
                var formats = allBindingsAccessor().dateFormats || { from: "", to: "L" };
                element.onchange = function() {
                    var observable = valueAccessor();
                    var value = moment(element.value, "L");
                    if (value && value.isValid()) {
                        //if format is not set then assume observed is a js date
                        if (formats.from) {
                            observable(value.format(formats.from));
                        } else {
                            observable(value.toDate());
                        }
                    } else {
                        observable("");
                        //ensures element is blank when invalid input is attempted
                        if (element.value) element.value = "";
                    }
                };
            },
            update: function(element, valueAccessor, allBindingsAccessor) {
                var formats = allBindingsAccessor().dateFormats || { from: "", to: "L" };
                var observable = valueAccessor();
                var valueUnwrapped = ko.utils.unwrapObservable(observable);
                if (valueUnwrapped) {
                    element.value = moment(valueUnwrapped).format(formats.to);
                } else {
                    element.value = "";
                }
            }
        };

        ko.bindingHandlers.dateText = {
            update: function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
                var valueUnwrapped = ko.utils.unwrapObservable(valueAccessor());
                var formatted = moment(valueUnwrapped).format("L");
                ko.bindingHandlers.text.update(element, function() { return formatted; });
            }
        };

        ko.applyBindings(new ContractsViewModel());

    //$(function() {
        //    $.datepicker.setDefaults($.datepicker.regional['cs']);
        //    $("[datepicker='datepicker']").datepicker();
        //});


    </script>
}

<div id="body">
    <section class="featured">
        <div class="content-wrapper">
            <div>
                <button>Všechny typy</button>
                <button>Smlouvy o dílo</button>
                <button>Mandátní smlouvy</button>
                <button>Kupní smlouvy</button>
                <button>Nájemní smlouvy</button>
                <button>Ostatní smlouvy</button>
            </div>
        </div>
    </section>
    <section class="content-wrapper main-content clear-fix">
        <div class="container float-left">
            <img id="loader" src="images/ajax-loader.gif" data-bind="visible: !loaded()" />
            <div data-bind="visible: loaded">
                <form  data-bind="submit: $root.searchContracts">
                    <input type="text" data-bind="jqAuto: {autoFocus: true}, jqAutoSource: suggestions, jqAutoQuery: getSuggestions, jqAutoValue: searchText " placeholder="Vyhledávat podle předmětu a jmen" />
                    <button type="submit">Hledat</button>
                </form>
                <ul id="contracts" data-bind="foreach: contracts">
                    <li class="ui-widget-content contract">
                        <h2 data-bind="text: Subject" class="ui-widget-header"></h2>
                        <div class="contract-price"><span>Cena: </span><span data-bind="text: Price"></span></div>
                        <div class="contract-signedOn"><span>Podepsána: </span><span data-bind="dateText: SignedOn"></span></div>
                        <div class="contract-party" data-bind="with: FirstParty">
                            <label>Objednatel</label>
                            @Html.Partial("Partial/ContactView")
                        </div>
                        <div class="contract-party" data-bind="with: SecondParty">
                            <label>Zhotovitel</label>
                            @Html.Partial("Partial/ContactView")
                        </div>
                    </li>
                </ul>
            </div>
        </div>
        <div class="addContainer float-left" data-bind="with: newContract">
            @Html.Partial("AddContract")
        </div>
    </section>

</div>
